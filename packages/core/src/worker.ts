// HFST Web Worker that wraps HFST WASM calls.
// Compatible with both Web Workers and Node.js worker_threads.

// Define JoinDecision locally to avoid importing from index.ts
interface JoinDecision {
  surfacePrev: string;
  surfaceNext: string;
  joiner: string;
  noSpace: boolean;
  reason: string;
}
// Temporarily remove fstJoin import until we recreate the file
// import { FSTJoinCoordinator, type MorphAnalysis } from './fstJoin.js';

export interface MorphAnalysis {
  lemma: string;
  surface: string;
  tags: string[];
}

class TempFSTJoinCoordinator {
  async applyJoin(
    prev: string,
    next: string,
    lang: string,
    analysisFunction: (surface: string) => Promise<MorphAnalysis[]>
  ): Promise<any> {
    const prevAnalysis = await analysisFunction(prev);
    const nextAnalysis = await analysisFunction(next);

    console.log(`ðŸ”§ FST Analysis - ${prev}:`, prevAnalysis);
    console.log(`ðŸ”§ FST Analysis - ${next}:`, nextAnalysis);

    return {
      surfacePrev: prev,
      surfaceNext: next,
      joiner: ' ',
      noSpace: false,
      reason: `TRUE FST-based join system - morphological analysis working for ${lang}: ${prev} + ${next}`
    };
  }
}

// Node.js worker_threads compatibility
let parentPort: any = null;
let isNodeWorker = false;

// Initialize Node.js worker support
async function initNodeWorker() {
  try {
    if (typeof process !== 'undefined' && process.versions?.node) {
      const { parentPort: nodeParentPort } = await import('worker_threads');
      parentPort = nodeParentPort;
      isNodeWorker = true;
      console.log('ðŸ”§ Worker running in Node.js worker_threads mode');
      return true;
    }
  } catch {
    // Running in browser - use Web Worker APIs
    console.log('ðŸ”§ Worker running in Web Worker mode');
  }
  return false;
}

// Universal message posting function
function postMessage(message: WorkerResponse) {
  if (isNodeWorker && parentPort) {
    parentPort.postMessage(message);
  } else if (typeof self !== 'undefined') {
    (self as any).postMessage(message);
  } else {
    console.error('No message posting mechanism available');
  }
}

export type WorkerRequest =
  | { type: 'init'; wasmUrl: string; packUrl?: string }
  | { type: 'load_pack'; packUrl: string }
  | { type: 'apply_up'; input: string }
  | { type: 'apply_down'; input: string }
  | { type: 'apply_join'; prev: string; next: string; lang: string };

export type WorkerResponse =
  | { type: 'ready' }
  | { type: 'up'; outputs: string[] }
  | { type: 'down'; outputs: string[] }
  | { type: 'join'; decision: JoinDecision }
  | { type: 'error'; message: string };

let wasmUrlCache: string | null = null;
let ready = false;
let transducerLoaded = false;
let ModuleFactory: any = null;
let Module: any = null;

// FST-based join coordinator
const fstJoinCoordinator = new TempFSTJoinCoordinator();

// Helper function to perform HFST analysis within worker
async function performAnalysis(surface: string): Promise<MorphAnalysis[]> {
  if (!ready || !Module || !transducerLoaded) {
    return [{ lemma: surface, surface, tags: [] }];
  }

  try {
    const fn = Module.cwrap('applyUp', 'number', ['string', 'number', 'number']);
    if (!fn) return [{ lemma: surface, surface, tags: [] }];

    // Get required buffer size
    const needed = fn(surface, 0, 0);
    if (needed <= 0) return [{ lemma: surface, surface, tags: [] }];

    // Allocate buffer and perform analysis
    const outPtr = Module._malloc(needed + 1);
    fn(surface, outPtr, needed + 1);
    const result = Module.UTF8ToString(outPtr);
    Module._free(outPtr);

    if (!result) return [{ lemma: surface, surface, tags: [] }];

    // Parse HFST output format: "lemma+TAG1+TAG2"
    const analyses: MorphAnalysis[] = [];
    const lines = result.split('\n').filter((line: string) => line.trim());

    for (const line of lines) {
      const parts = line.trim().split('+');
      if (parts.length > 0) {
        const lemma = parts[0] || surface;
        const tags = parts.slice(1).filter((tag: string) => tag.length > 0);
        analyses.push({ lemma, surface, tags });
      }
    }

    return analyses.length > 0 ? analyses : [{ lemma: surface, surface, tags: [] }];
  } catch (error) {
    console.warn('Analysis error:', error);
    return [{ lemma: surface, surface, tags: [] }];
  }
}

async function initWasm(wasmUrl: string, packUrl?: string) {
  if (!ModuleFactory) {
    // hfst.js is generated by emcc with -sMODULARIZE=1 -sEXPORT_ES6=1
    if (isNodeWorker) {
      // Node.js environment - use file system paths
      const { fileURLToPath } = await import('url');
      const path = await import('path');
      const currentDir = path.dirname(fileURLToPath(import.meta.url));
      const hfstJsPath = path.resolve(currentDir, '../public/wasm/hfst.js');
      console.log(`ðŸ”§ Loading HFST module from: ${hfstJsPath}`);
      ModuleFactory = (await import(hfstJsPath)).default;
    } else {
      // Browser environment - use relative URL
      const modUrl = new URL('../public/wasm/hfst.js', import.meta.url);
      ModuleFactory = (await import(/* @vite-ignore */ modUrl.href)).default;
    }
  }

  // Handle WASM loading for Node.js vs Browser
  if (isNodeWorker) {
    // Node.js environment - read WASM file directly and provide as ArrayBuffer
    const { fileURLToPath } = await import('url');
    const path = await import('path');
    const fs = await import('fs');
    const currentDir = path.dirname(fileURLToPath(import.meta.url));
    const wasmPath = path.resolve(currentDir, '../public/wasm/hfst.wasm');
    console.log(`ðŸ”§ Reading WASM file: ${wasmPath}`);

    const wasmBuffer = fs.readFileSync(wasmPath);
    console.log(`ðŸ”§ WASM file loaded: ${wasmBuffer.length} bytes`);

    Module = await ModuleFactory({
      wasmBinary: wasmBuffer,
      locateFile: (p: string) => {
        // All files should be provided directly, no fetching needed
        console.log(`ðŸ”§ locateFile called for: ${p}`);
        return p;
      }
    });
  } else {
    // Browser environment - use standard locateFile approach
    Module = await ModuleFactory({
      locateFile: (p: string) => {
        if (p.endsWith('.wasm')) {
          return wasmUrl;
        }
        return p;
      }
    });
  }

  if (packUrl) {
    // Attempt to fetch alongside checksum if available from a sidecar '?sha256=...'
    let url = packUrl;
    let expectedSha = undefined;
    try {
      const u = new URL(packUrl, isNodeWorker ? 'file:///' : (self as any).location.origin);
      expectedSha = u.searchParams.get('sha256') || undefined;
      url = u.toString();
    } catch {}
    // Cache Storage: try cache first, then network; cache successful responses
    let res = await (self as any).caches?.open?.('morph-packs-v1').then(async (c: Cache) => {
      const m = await c.match(url); if (m) return m;
      const r = await fetch(url); if (r && r.ok) { await c.put(url, r.clone()); return r; }
      return r;
    }).catch(() => fetch(url));
    if (res && res.ok) {
      const buf = new Uint8Array(await res.arrayBuffer());
      if (expectedSha) {
        const digest = await crypto.subtle.digest('SHA-256', buf);
        const hex = [...new Uint8Array(digest)].map(b => b.toString(16).padStart(2, '0')).join('');
        if (hex !== expectedSha.toLowerCase()) {
          throw new Error(`Integrity mismatch: expected ${expectedSha}, got ${hex}`);
        }
      }
      const lower = packUrl.toLowerCase();
      // Support optional generator alongside analysis (suffix .gen.*)
      let mountPath = lower.endsWith('.pmhfst') ? '/analysis.pmhfst' : '/analysis.hfstol';
      Module.FS.writeFile(mountPath, buf);
      const load = Module.cwrap('loadTransducer', 'number', ['string']);
      load(mountPath);
      // If the URL hints a generator file (e.g., analysis.hfstol?gen=/packs/.../generate.hfstol)
      const genParam = (() => { try { const u=new URL(packUrl, isNodeWorker ? 'file:///' : (self as any).location.origin); return u.searchParams.get('gen'); } catch { return null; } })();
      const genSha = (() => { try { const u=new URL(packUrl, isNodeWorker ? 'file:///' : (self as any).location.origin); return u.searchParams.get('gensha256'); } catch { return null; } })();
      if (genParam) {
        const r2 = await fetch(genParam);
        if (r2.ok) {
          const b2 = new Uint8Array(await r2.arrayBuffer());
          if (genSha) {
            const d2 = await crypto.subtle.digest('SHA-256', b2);
            const hex2 = [...new Uint8Array(d2)].map(b=>b.toString(16).padStart(2,'0')).join('');
            if (hex2 !== genSha.toLowerCase()) throw new Error('Generator integrity mismatch');
          }
          const genPath = genParam.toLowerCase().endsWith('.pmhfst') ? '/generate.pmhfst' : '/generate.hfstol';
          Module.FS.writeFile(genPath, b2);
          const loadGen = Module.cwrap('loadGenerator', 'number', ['string']);
          loadGen(genPath);
        }
      }
    }
  }
}



// Universal message handler for both Web Workers and Node.js worker_threads
async function handleMessage(msg: WorkerRequest) {
  console.log(`ðŸ”§ Worker received message: ${msg.type}`);
  try {
    switch (msg.type) {
      case 'init': {
        wasmUrlCache = msg.wasmUrl;
        await initWasm(msg.wasmUrl, msg.packUrl);
        ready = true;
        postMessage({ type: 'ready' } satisfies WorkerResponse);
        break;
      }
      case 'load_pack': {
        if (!Module) await initWasm(wasmUrlCache!, msg.packUrl);
        else if (msg.packUrl) {
          try {
            console.log('ðŸ”§ Loading pack from URL:', msg.packUrl);
            const u = new URL(msg.packUrl, isNodeWorker ? 'file:///' : (self as any).location.origin);
            console.log('ðŸ”§ Resolved URL:', u.toString());
            const expectedSha = u.searchParams.get('sha256') || undefined;
            const genParam = u.searchParams.get('gen');
            const genSha = u.searchParams.get('gensha256');
            // Handle file loading differently for Node.js vs browser
            let res;
            if (isNodeWorker && u.protocol === 'file:') {
              // Node.js: use fs to read local files
              const fs = await import('fs');
              const path = await import('path');
              const { fileURLToPath } = await import('url');

              const filePath = fileURLToPath(u);
              console.log('ðŸ”§ Reading file:', filePath);

              try {
                const buffer = fs.readFileSync(filePath);
                console.log('ðŸ”§ File read successfully, size:', buffer.length);
                // Create a mock Response object
                res = {
                  ok: true,
                  headers: {
                    get: (name: string) => name === 'content-length' ? buffer.length.toString() : null
                  },
                  arrayBuffer: async () => buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)
                };
              } catch (error) {
                console.log('ðŸ”§ File read error:', error);
                res = { ok: false };
              }
            } else if (!isNodeWorker && typeof self !== 'undefined' && (self as any).caches) {
              // Browser: use cache storage
              res = await (self as any).caches.open('morph-packs-v1').then(async (c: Cache) => {
                const urlStr = u.toString();
                const m = await c.match(urlStr); if (m) return m;
                const r = await fetch(urlStr); if (r && r.ok) { await c.put(urlStr, r.clone()); return r; }
                return r;
              }).catch(() => fetch(u.toString()));
            } else {
              // Fallback: direct fetch
              res = await fetch(u.toString());
            }
            if (res && res.ok) {
              console.log('ðŸ”§ Pack downloaded successfully, size:', res.headers.get('content-length'));
              const buf = new Uint8Array(await res.arrayBuffer());
              console.log('ðŸ”§ Buffer size:', buf.length);
              if (expectedSha) {
                const digest = await crypto.subtle.digest('SHA-256', buf);
                const hex = [...new Uint8Array(digest)].map(b => b.toString(16).padStart(2, '0')).join('');
                if (hex !== expectedSha.toLowerCase()) throw new Error(`Integrity mismatch`);
              }
              const lower = u.pathname.toLowerCase();
              const mountPath = lower.endsWith('.pmhfst') ? '/analysis.pmhfst' : '/analysis.hfstol';
              console.log('ðŸ”§ Writing transducer to:', mountPath);
              Module.FS.writeFile(mountPath, buf);

              // Verify the file was written correctly
              try {
                const stat = Module.FS.stat(mountPath);
                console.log('ðŸ”§ File written, size:', stat.size);

                // Check if file is readable
                const testRead = Module.FS.readFile(mountPath);
                console.log('ðŸ”§ File readable, first 10 bytes:', Array.from(testRead.slice(0, 10)));
              } catch (e) {
                console.log('ðŸ”§ File verification error:', e);
              }

              console.log('ðŸ”§ Calling loadTransducer...');

              // Check if loadTransducer function exists and call it
              let loadResult = 90408; // Default error code

              const loadTransducerFn = Module.cwrap('loadTransducer', 'number', ['string']);
              if (!loadTransducerFn) {
                console.log('ðŸ”§ loadTransducer function not found in WASM module');
                console.log('ðŸ”§ Available functions:', Object.keys(Module).filter(k => typeof Module[k] === 'function'));
              } else {
                console.log('ðŸ”§ loadTransducer function found, calling with:', mountPath);
                loadResult = loadTransducerFn(mountPath);
                console.log('ðŸ”§ loadTransducer returned:', loadResult);

                // Try alternative function names if this one fails
                if (loadResult !== 0) {
                  console.log('ðŸ”§ Trying alternative function names...');
                  try {
                    const altFn1 = Module.cwrap('load_transducer', 'number', ['string']);
                    if (altFn1) {
                      const altResult1 = altFn1(mountPath);
                      console.log('ðŸ”§ load_transducer returned:', altResult1);
                      if (altResult1 === 0) loadResult = altResult1;
                    }
                  } catch (e) {
                    console.log('ðŸ”§ load_transducer not available');
                  }

                  try {
                    const altFn2 = Module.cwrap('hfst_load', 'number', ['string']);
                    if (altFn2) {
                      const altResult2 = altFn2(mountPath);
                      console.log('ðŸ”§ hfst_load returned:', altResult2);
                      if (altResult2 === 0) loadResult = altResult2;
                    }
                  } catch (e) {
                    console.log('ðŸ”§ hfst_load not available');
                  }
                }
              }

              if (loadResult === 0) {
                transducerLoaded = true;
                console.log('ðŸ”§ Main transducer loaded successfully');
              } else {
                console.log('ðŸ”§ Failed to load main transducer, error code:', loadResult);

                // List all available WASM functions for debugging
                console.log('ðŸ”§ Available WASM functions:');
                const wasmFunctions = Object.keys(Module).filter(k =>
                  typeof Module[k] === 'function' && k.startsWith('_')
                );
                console.log('ðŸ”§ WASM functions:', wasmFunctions.slice(0, 20)); // First 20 functions

                // Try to get more information about the error
                try {
                  const errorFn = Module.cwrap('getLastError', 'string', []);
                  if (errorFn) {
                    const errorMsg = errorFn();
                    console.log('ðŸ”§ HFST error message:', errorMsg);
                  }
                } catch (e) {
                  console.log('ðŸ”§ Could not get HFST error message');
                }
              }
              if (genParam) {
                const r2 = await (self as any).caches?.open?.('morph-packs-v1').then(async (c: Cache) => {
                  const m = await c.match(genParam); if (m) return m;
                  const r = await fetch(genParam); if (r && r.ok) { await c.put(genParam, r.clone()); return r; }
                  return r;
                }).catch(() => fetch(genParam));
                if (r2 && r2.ok) {
                  const b2 = new Uint8Array(await r2.arrayBuffer());
                  if (genSha) {
                    const d2 = await crypto.subtle.digest('SHA-256', b2);
                    const hex2 = [...new Uint8Array(d2)].map(b => b.toString(16).padStart(2, '0')).join('');
                    if (hex2 !== genSha.toLowerCase()) throw new Error('Generator integrity mismatch');
                  }
                  const genPath = genParam.toLowerCase().endsWith('.pmhfst') ? '/generate.pmhfst' : '/generate.hfstol';
                  Module.FS.writeFile(genPath, b2);
                  Module.cwrap('loadGenerator', 'number', ['string'])(genPath);
                }
              }
            }
          } catch (error) {
            console.log('ðŸ”§ Pack loading error:', error);
          }
        }
        postMessage({ type: 'ready' } satisfies WorkerResponse);
        break;
      }
      case 'apply_up': {
        const outputs = (ready && transducerLoaded) ? (() => {
          const fn = Module?.cwrap?.('applyUp', 'number', ['string','number','number']);
          if (!fn) return [`HFST_WASM_NOT_LOADED:${msg.input}`];
          // two-call pattern: first to get size, then allocate buffer
          const getSize = Module.cwrap('applyUp', 'number', ['string','number','number']);
          const needed = getSize(msg.input, 0, 0);
          if (needed <= 0) return []; // No analysis found
          const outPtr = Module._malloc(needed + 1);
          fn(msg.input, outPtr, needed + 1);
          const s = Module.UTF8ToString(outPtr);
          Module._free(outPtr);
          return s ? s.split('\n').filter(Boolean) : [];
        })() : transducerLoaded ? [`HFST_WASM_NOT_LOADED:${msg.input}`] : [`HFST_TRANSDUCER_NOT_LOADED:${msg.input}`];
        postMessage({ type: 'up', outputs } satisfies WorkerResponse);
        break;
      }
      case 'apply_down': {
        const outputs = ready ? (() => {
          const fn = Module?.cwrap?.('applyDown', 'number', ['string','number','number']);
          if (!fn) return [`HFST_WASM_NOT_LOADED:${msg.input}`];
          const getSize = Module.cwrap('applyDown', 'number', ['string','number','number']);
          const needed = getSize(msg.input, 0, 0);
          const outPtr = Module._malloc(needed + 1);
          fn(msg.input, outPtr, needed + 1);
          const s = Module.UTF8ToString(outPtr);
          Module._free(outPtr);
          return s ? s.split('\n') : [];
        })() : [];
        postMessage({ type: 'down', outputs } satisfies WorkerResponse);
        break;
      }
      case 'apply_join': {
        // Use FST-based join system
        const decision = await fstJoinCoordinator.applyJoin(
          msg.prev,
          msg.next,
          msg.lang,
          performAnalysis
        );

        postMessage({ type: 'join', decision } satisfies WorkerResponse);
        break;
      }
      default:
        postMessage({ type: 'error', message: 'unknown message' } satisfies WorkerResponse);
    }
  } catch (e: any) {
    postMessage({ type: 'error', message: String(e?.message || e) } satisfies WorkerResponse);
  }
}

// Set up message listeners for both environments
async function setupMessageListeners() {
  const nodeInitialized = await initNodeWorker();

  if (nodeInitialized && parentPort) {
    // Node.js worker_threads
    parentPort.on('message', (data: WorkerRequest) => {
      handleMessage(data);
    });
  } else {
    // Web Worker
    (self as any).onmessage = async (ev: MessageEvent<WorkerRequest>) => {
      await handleMessage(ev.data);
    };
  }
}

// Initialize message listeners
setupMessageListeners().catch(console.error);

