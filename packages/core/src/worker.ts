// Placeholder Web Worker that would wrap HFST WASM calls in the future.
// For now, it echoes a minimal interface.

export type WorkerRequest =
  | { type: 'init'; wasmUrl: string; packUrl?: string }
  | { type: 'load_pack'; packUrl: string }
  | { type: 'apply_up'; input: string }
  | { type: 'apply_down'; input: string };

export type WorkerResponse =
  | { type: 'ready' }
  | { type: 'up'; outputs: string[] }
  | { type: 'down'; outputs: string[] }
  | { type: 'error'; message: string };

let wasmUrlCache: string | null = null;
let ready = false;
let ModuleFactory: any = null;
let Module: any = null;

async function initWasm(wasmUrl: string, packUrl?: string) {
  if (!ModuleFactory) {
    // hfst.js is generated by emcc with -sMODULARIZE=1 -sEXPORT_ES6=1
    const modUrl = new URL('../public/wasm/hfst.js', import.meta.url);
    ModuleFactory = (await import(/* @vite-ignore */ modUrl.href)).default;
  }
  Module = await ModuleFactory({ locateFile: (p: string) => {
    if (p.endsWith('.wasm')) return wasmUrl;
    return p;
  }});

  if (packUrl) {
    // Attempt to fetch alongside checksum if available from a sidecar '?sha256=...'
    let url = packUrl;
    let expectedSha = undefined;
    try {
      const u = new URL(packUrl, self.location.origin);
      expectedSha = u.searchParams.get('sha256') || undefined;
      url = u.toString();
    } catch {}
    const res = await fetch(url);
    if (res.ok) {
      const buf = new Uint8Array(await res.arrayBuffer());
      if (expectedSha) {
        const digest = await crypto.subtle.digest('SHA-256', buf);
        const hex = [...new Uint8Array(digest)].map(b => b.toString(16).padStart(2, '0')).join('');
        if (hex !== expectedSha.toLowerCase()) {
          throw new Error(`Integrity mismatch: expected ${expectedSha}, got ${hex}`);
        }
      }
      const lower = packUrl.toLowerCase();
      // Support optional generator alongside analysis (suffix .gen.*)
      let mountPath = lower.endsWith('.pmhfst') ? '/analysis.pmhfst' : '/analysis.hfstol';
      Module.FS.writeFile(mountPath, buf);
      const load = Module.cwrap('loadTransducer', 'number', ['string']);
      load(mountPath);
      // If the URL hints a generator file (e.g., analysis.hfstol?gen=/packs/.../generate.hfstol)
      const genParam = (() => { try { return new URL(packUrl, self.location.origin).searchParams.get('gen'); } catch { return null; } })();
      if (genParam) {
        const r2 = await fetch(genParam);
        if (r2.ok) {
          const b2 = new Uint8Array(await r2.arrayBuffer());
          const genPath = genParam.toLowerCase().endsWith('.pmhfst') ? '/generate.pmhfst' : '/generate.hfstol';
          Module.FS.writeFile(genPath, b2);
          const loadGen = Module.cwrap('loadGenerator', 'number', ['string']);
          loadGen(genPath);
        }
      }
    }
  }
}

self.onmessage = async (ev: MessageEvent<WorkerRequest>) => {
  const msg = ev.data;
  try {
    switch (msg.type) {
      case 'init': {
        wasmUrlCache = msg.wasmUrl;
        await initWasm(msg.wasmUrl, msg.packUrl);
        ready = true;
        (self as any).postMessage({ type: 'ready' } satisfies WorkerResponse);
        break;
      }
      case 'load_pack': {
        if (!Module) await initWasm(wasmUrlCache!, msg.packUrl);
        else if (msg.packUrl) {
          try {
            const res = await fetch(msg.packUrl);
            if (res.ok) {
              const buf = new Uint8Array(await res.arrayBuffer());
              Module.FS.writeFile('/pack.hfstol', buf);
              const load = Module.cwrap('loadTransducer', 'number', ['string']);
              load('/pack.hfstol');
            }
          } catch {}
        }
        (self as any).postMessage({ type: 'ready' } satisfies WorkerResponse);
        break;
      }
      case 'apply_up': {
        const outputs = ready ? (() => {
          const fn = Module?.cwrap?.('applyUp', 'number', ['string','number','number']);
          if (!fn) return [msg.input];
          // two-call pattern: first to get size, then allocate buffer
          const getSize = Module.cwrap('applyUp', 'number', ['string','number','number']);
          const needed = getSize(msg.input, 0, 0);
          const outPtr = Module._malloc(needed + 1);
          const wrote = fn(msg.input, outPtr, needed + 1);
          const s = Module.UTF8ToString(outPtr);
          Module._free(outPtr);
          return s ? s.split('\n') : [];
        })() : [];
        (self as any).postMessage({ type: 'up', outputs } satisfies WorkerResponse);
        break;
      }
      case 'apply_down': {
        const outputs = ready ? (() => {
          const fn = Module?.cwrap?.('applyDown', 'number', ['string','number','number']);
          if (!fn) return [msg.input];
          const getSize = Module.cwrap('applyDown', 'number', ['string','number','number']);
          const needed = getSize(msg.input, 0, 0);
          const outPtr = Module._malloc(needed + 1);
          const wrote = fn(msg.input, outPtr, needed + 1);
          const s = Module.UTF8ToString(outPtr);
          Module._free(outPtr);
          return s ? s.split('\n') : [];
        })() : [];
        (self as any).postMessage({ type: 'down', outputs } satisfies WorkerResponse);
        break;
      }
      default:
        (self as any).postMessage({ type: 'error', message: 'unknown message' } satisfies WorkerResponse);
    }
  } catch (e: any) {
    (self as any).postMessage({ type: 'error', message: String(e?.message || e) } satisfies WorkerResponse);
  }
};

