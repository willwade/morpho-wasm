// Placeholder Web Worker that would wrap HFST WASM calls in the future.
// For now, it echoes a minimal interface.
let wasmUrlCache = null;
let ready = false;
let ModuleFactory = null;
let Module = null;
async function initWasm(wasmUrl, packUrl) {
    if (!ModuleFactory) {
        // hfst.js is generated by emcc with -sMODULARIZE=1 -sEXPORT_ES6=1
        const modUrl = new URL('../public/wasm/hfst.js', import.meta.url);
        ModuleFactory = (await import(/* @vite-ignore */ modUrl.href)).default;
    }
    Module = await ModuleFactory({ locateFile: (p) => {
            if (p.endsWith('.wasm'))
                return wasmUrl;
            return p;
        } });
    if (packUrl) {
        const res = await fetch(packUrl);
        if (res.ok) {
            const buf = new Uint8Array(await res.arrayBuffer());
            // Mount at /pack.hfstol
            Module.FS.writeFile('/pack.hfstol', buf);
            const load = Module.cwrap('loadTransducer', 'number', ['string']);
            load('/pack.hfstol');
        }
    }
}
self.onmessage = async (ev) => {
    const msg = ev.data;
    try {
        switch (msg.type) {
            case 'init': {
                wasmUrlCache = msg.wasmUrl;
                await initWasm(msg.wasmUrl, msg.packUrl);
                ready = true;
                self.postMessage({ type: 'ready' });
                break;
            }
            case 'load_pack': {
                if (!Module)
                    await initWasm(wasmUrlCache, msg.packUrl);
                else if (msg.packUrl) {
                    try {
                        const res = await fetch(msg.packUrl);
                        if (res.ok) {
                            const buf = new Uint8Array(await res.arrayBuffer());
                            Module.FS.writeFile('/pack.hfstol', buf);
                            const load = Module.cwrap('loadTransducer', 'number', ['string']);
                            load('/pack.hfstol');
                        }
                    }
                    catch { }
                }
                self.postMessage({ type: 'ready' });
                break;
            }
            case 'apply_up': {
                const outputs = ready ? (() => {
                    const fn = Module?.cwrap?.('applyUp', 'number', ['string', 'number', 'number']);
                    if (!fn)
                        return [msg.input];
                    // two-call pattern: first to get size, then allocate buffer
                    const getSize = Module.cwrap('applyUp', 'number', ['string', 'number', 'number']);
                    const needed = getSize(msg.input, 0, 0);
                    const outPtr = Module._malloc(needed + 1);
                    const wrote = fn(msg.input, outPtr, needed + 1);
                    const s = Module.UTF8ToString(outPtr);
                    Module._free(outPtr);
                    return s ? s.split('\n') : [];
                })() : [];
                self.postMessage({ type: 'up', outputs });
                break;
            }
            case 'apply_down': {
                const outputs = ready ? (() => {
                    const fn = Module?.cwrap?.('applyDown', 'number', ['string', 'number', 'number']);
                    if (!fn)
                        return [msg.input];
                    const getSize = Module.cwrap('applyDown', 'number', ['string', 'number', 'number']);
                    const needed = getSize(msg.input, 0, 0);
                    const outPtr = Module._malloc(needed + 1);
                    const wrote = fn(msg.input, outPtr, needed + 1);
                    const s = Module.UTF8ToString(outPtr);
                    Module._free(outPtr);
                    return s ? s.split('\n') : [];
                })() : [];
                self.postMessage({ type: 'down', outputs });
                break;
            }
            default:
                self.postMessage({ type: 'error', message: 'unknown message' });
        }
    }
    catch (e) {
        self.postMessage({ type: 'error', message: String(e?.message || e) });
    }
};
export {};
