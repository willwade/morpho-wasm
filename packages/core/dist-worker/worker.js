// Placeholder Web Worker that would wrap HFST WASM calls in the future.
// For now, it echoes a minimal interface.
let wasmUrlCache = null;
let ready = false;
let ModuleFactory = null;
let Module = null;
async function initWasm(wasmUrl, packUrl) {
    if (!ModuleFactory) {
        // hfst.js is generated by emcc with -sMODULARIZE=1 -sEXPORT_ES6=1
        const modUrl = new URL('../public/wasm/hfst.js', import.meta.url);
        ModuleFactory = (await import(/* @vite-ignore */ modUrl.href)).default;
    }
    Module = await ModuleFactory({ locateFile: (p) => {
            if (p.endsWith('.wasm'))
                return wasmUrl;
            return p;
        } });
    if (packUrl) {
        // Attempt to fetch alongside checksum if available from a sidecar '?sha256=...'
        let url = packUrl;
        let expectedSha = undefined;
        try {
            const u = new URL(packUrl, self.location.origin);
            expectedSha = u.searchParams.get('sha256') || undefined;
            url = u.toString();
        }
        catch { }
        // Cache Storage: try cache first, then network; cache successful responses
        let res = await self.caches?.open?.('morph-packs-v1').then(async (c) => {
            const m = await c.match(url);
            if (m)
                return m;
            const r = await fetch(url);
            if (r && r.ok) {
                await c.put(url, r.clone());
                return r;
            }
            return r;
        }).catch(() => fetch(url));
        if (res && res.ok) {
            const buf = new Uint8Array(await res.arrayBuffer());
            if (expectedSha) {
                const digest = await crypto.subtle.digest('SHA-256', buf);
                const hex = [...new Uint8Array(digest)].map(b => b.toString(16).padStart(2, '0')).join('');
                if (hex !== expectedSha.toLowerCase()) {
                    throw new Error(`Integrity mismatch: expected ${expectedSha}, got ${hex}`);
                }
            }
            const lower = packUrl.toLowerCase();
            // Support optional generator alongside analysis (suffix .gen.*)
            let mountPath = lower.endsWith('.pmhfst') ? '/analysis.pmhfst' : '/analysis.hfstol';
            Module.FS.writeFile(mountPath, buf);
            const load = Module.cwrap('loadTransducer', 'number', ['string']);
            load(mountPath);
            // If the URL hints a generator file (e.g., analysis.hfstol?gen=/packs/.../generate.hfstol)
            const genParam = (() => { try {
                const u = new URL(packUrl, self.location.origin);
                return u.searchParams.get('gen');
            }
            catch {
                return null;
            } })();
            const genSha = (() => { try {
                const u = new URL(packUrl, self.location.origin);
                return u.searchParams.get('gensha256');
            }
            catch {
                return null;
            } })();
            if (genParam) {
                const r2 = await fetch(genParam);
                if (r2.ok) {
                    const b2 = new Uint8Array(await r2.arrayBuffer());
                    if (genSha) {
                        const d2 = await crypto.subtle.digest('SHA-256', b2);
                        const hex2 = [...new Uint8Array(d2)].map(b => b.toString(16).padStart(2, '0')).join('');
                        if (hex2 !== genSha.toLowerCase())
                            throw new Error('Generator integrity mismatch');
                    }
                    const genPath = genParam.toLowerCase().endsWith('.pmhfst') ? '/generate.pmhfst' : '/generate.hfstol';
                    Module.FS.writeFile(genPath, b2);
                    const loadGen = Module.cwrap('loadGenerator', 'number', ['string']);
                    loadGen(genPath);
                }
            }
        }
    }
}
self.onmessage = async (ev) => {
    const msg = ev.data;
    try {
        switch (msg.type) {
            case 'init': {
                wasmUrlCache = msg.wasmUrl;
                await initWasm(msg.wasmUrl, msg.packUrl);
                ready = true;
                self.postMessage({ type: 'ready' });
                break;
            }
            case 'load_pack': {
                if (!Module)
                    await initWasm(wasmUrlCache, msg.packUrl);
                else if (msg.packUrl) {
                    try {
                        const u = new URL(msg.packUrl, self.location.origin);
                        const expectedSha = u.searchParams.get('sha256') || undefined;
                        const genParam = u.searchParams.get('gen');
                        const genSha = u.searchParams.get('gensha256');
                        // Cache Storage for analysis URL
                        let res = await self.caches?.open?.('morph-packs-v1').then(async (c) => {
                            const urlStr = u.toString();
                            const m = await c.match(urlStr);
                            if (m)
                                return m;
                            const r = await fetch(urlStr);
                            if (r && r.ok) {
                                await c.put(urlStr, r.clone());
                                return r;
                            }
                            return r;
                        }).catch(() => fetch(u.toString()));
                        if (res && res.ok) {
                            const buf = new Uint8Array(await res.arrayBuffer());
                            if (expectedSha) {
                                const digest = await crypto.subtle.digest('SHA-256', buf);
                                const hex = [...new Uint8Array(digest)].map(b => b.toString(16).padStart(2, '0')).join('');
                                if (hex !== expectedSha.toLowerCase())
                                    throw new Error(`Integrity mismatch`);
                            }
                            const lower = u.pathname.toLowerCase();
                            const mountPath = lower.endsWith('.pmhfst') ? '/analysis.pmhfst' : '/analysis.hfstol';
                            Module.FS.writeFile(mountPath, buf);
                            Module.cwrap('loadTransducer', 'number', ['string'])(mountPath);
                            if (genParam) {
                                const r2 = await self.caches?.open?.('morph-packs-v1').then(async (c) => {
                                    const m = await c.match(genParam);
                                    if (m)
                                        return m;
                                    const r = await fetch(genParam);
                                    if (r && r.ok) {
                                        await c.put(genParam, r.clone());
                                        return r;
                                    }
                                    return r;
                                }).catch(() => fetch(genParam));
                                if (r2 && r2.ok) {
                                    const b2 = new Uint8Array(await r2.arrayBuffer());
                                    if (genSha) {
                                        const d2 = await crypto.subtle.digest('SHA-256', b2);
                                        const hex2 = [...new Uint8Array(d2)].map(b => b.toString(16).padStart(2, '0')).join('');
                                        if (hex2 !== genSha.toLowerCase())
                                            throw new Error('Generator integrity mismatch');
                                    }
                                    const genPath = genParam.toLowerCase().endsWith('.pmhfst') ? '/generate.pmhfst' : '/generate.hfstol';
                                    Module.FS.writeFile(genPath, b2);
                                    Module.cwrap('loadGenerator', 'number', ['string'])(genPath);
                                }
                            }
                        }
                    }
                    catch { }
                }
                self.postMessage({ type: 'ready' });
                break;
            }
            case 'apply_up': {
                const outputs = ready ? (() => {
                    const fn = Module?.cwrap?.('applyUp', 'number', ['string', 'number', 'number']);
                    if (!fn)
                        return [msg.input];
                    // two-call pattern: first to get size, then allocate buffer
                    const getSize = Module.cwrap('applyUp', 'number', ['string', 'number', 'number']);
                    const needed = getSize(msg.input, 0, 0);
                    const outPtr = Module._malloc(needed + 1);
                    const wrote = fn(msg.input, outPtr, needed + 1);
                    const s = Module.UTF8ToString(outPtr);
                    Module._free(outPtr);
                    return s ? s.split('\n') : [];
                })() : [];
                self.postMessage({ type: 'up', outputs });
                break;
            }
            case 'apply_down': {
                const outputs = ready ? (() => {
                    const fn = Module?.cwrap?.('applyDown', 'number', ['string', 'number', 'number']);
                    if (!fn)
                        return [msg.input];
                    const getSize = Module.cwrap('applyDown', 'number', ['string', 'number', 'number']);
                    const needed = getSize(msg.input, 0, 0);
                    const outPtr = Module._malloc(needed + 1);
                    const wrote = fn(msg.input, outPtr, needed + 1);
                    const s = Module.UTF8ToString(outPtr);
                    Module._free(outPtr);
                    return s ? s.split('\n') : [];
                })() : [];
                self.postMessage({ type: 'down', outputs });
                break;
            }
            default:
                self.postMessage({ type: 'error', message: 'unknown message' });
        }
    }
    catch (e) {
        self.postMessage({ type: 'error', message: String(e?.message || e) });
    }
};
export {};
